---  
title: url输入浏览器运行过程  
date: 2020-12-06  
categories:  
 - frontEnd  
tags:  
 - http  
 - 浏览器  
---  
## 主体流程  
* DNS解析（域名转化为ip地址）  
* TCP连接（三次握手）  
* 浏览器发送http请求  
* 服务器处理请求  
* 浏览器解析并渲染页面  
* 断开连接（四次挥手）  

## DNS解析  
在DNS解析前，浏览器会首先进行url合法性和安全性检查，然后去查找缓存（这里可以扩展缓存知识）。  
DNS解析：域名转化为ip地址  
**DNS缓存查找顺序：**  
![dns1](@alias/dns.png)  
**DNS域名解析过程**  
![dns](@alias/dns1.png)  
**网址解析过程**  
* 高级域名到低级域名：. -> .com -> google.com. -> www.google.com.  

**DNS负载均衡技术**  
在DNS服务器中，为一个主机名配置多个ip地址，按需返回不同的解析结果，使不同的客户端访问不同的服务器。  
扩展：DNS解析过程中，还可能会发生DNS劫持问题，然后还有前端的dns-prefetch优化。  

## 建立TCP连接  
### 三次握手  
<img src="@alias/tcp1.png" style="zoom:36%"/>  
 
SYN（Synchronize Sequence Numbers）：同步序列编号  
ACK（Acknowledge character）：确认字符  

**过程：**  
1. 客户端给服务器发送一个SYN报文，并确定初始化序列号seq=x，此时SYN=1，报文段不能携带数据  
2. 服务器返回确认SYN报文，SYN=1，并缺点初始化序列号seq=y，并返回确认帧ACK=1，ACK确认号的值ack=x+1  
3. 客户端收到后返回确认帧ACK=1，确认号ack=y+1，序列号seq=x+1，此时ACK报文段可以携带数据，数据会消耗序号  

**1. 为什么需要三次握手，两次不行吗？**  
* 三次握手的目的是确认双方的接收与发送能力都正常。  
* 第三次为了防止已经失效的连接请求到达服务端，让服务器错误打开连接。  
* 如果只是两次握手就建立连接的话，若客户端之前发送的一些失效请求又到达了服务端，那么服务器就会发送确认，直接建立连接，然后等待客户端发送数据，实际上这时候客户端并没有要发送数据，浪费了资源。  

**2. SYN-ACK重传次数**  
服务器发送回SYN-ACK包，若未收到客户端确认包，则服务器进行重传，每次重传间隔时间一般是指数增长。  
若超过最大重传次数，则系统将该连接信息从半连接队列中删除。  

**3. ISN（Initial Sequence Number）是固定的吗？**  
客户端和服务端需要交换ISN，因为接收数据时要按照序列号组装数据，保证可靠传输。如果ISN固定，则攻击者容易猜出后序的确认号，因此ISN是动态生成的。  

**4. 三次握手过程中可以携带数据吗?**  
* 第三次握手可以携带数据，第一次、第二次不可以。  
* 如果第一次可以携带数据，那么服务器会比较容易受到恶意攻击，攻击者会发送很多数据给服务器，造成服务器响应缓慢。  
* 第三次握手客户端已经知道服务器的接收和发送能力，因此可以携带数据。  

**5. SYN洪泛攻击**  
一种典型的Dos/DDos攻击：  
* 服务器端资源是在第二次握手时分配，客户端资源是三次握手时分配，因此服务器容易受到SYN攻击  
* 客户端短时间内伪造大量不存在IP地址，向服务器不断发送SYN包，服务器发送回复但接收不到确认包，因此不断重发至超时  
* 伪造SYN包长时间占用队列，使正常SYN包被丢弃，使网络阻塞甚至瘫痪  

**防御SYN攻击的方法：**  
* 缩短超时（SYN Timeout）时间  
* 增加最大半连接数  
* 过滤网关防护  

**6. 第三次握手失败怎么办？**  
服务器不会重传ack报文，而是发送RST报文段，进入CLOSED状态，防止SYN洪泛攻击。  

**总结**  
* 三次握手建立连接的主要目的是同步序列号，保证可靠传输。  
* TCP很多特性如流量控制、消息重发等依赖于序列号  
* 因此，三次握手中的报文被称为SYN  

## 发送HTTP请求  
客户端向服务器发送HTTP请求（应用层），请求信息包括：  
请求头（Request Header）：请求方法、目标地址、遵循协议等  
请求主体（其他参数）  
注：可以扩充http字段知识  

## 服务器处理请求  
HTTP响应报文由以下部分构成：  
状态行  
响应头（Response Header）  
响应正文  

## 浏览器解析并渲染页面  
整体过程：  
构建DOM树 -> 构建CSSOM树 -> 构建render树 -> 绘制render树  
详细过程如下：  
* 解析HTML形成DOM树  
* 解析CSS形成CSSOM（CSS规则）树  
* 合并DOM树和CSSOM树形成布局树（Layout Tree） 
* 渲染并绘制页面  

**页面绘制过程：**  
* 回流：当页面中的一部分（或全部）因为元素的规模尺寸、布局，隐藏等属性改变而需要重新构建（也可以称为重布局或者重排）。每个页面至少产生一次回流，即第一次加载时。  
* 重绘：当页面中的一些元素需要更新属性，而这些属性只影响元素的外观，诸如背景颜色、文字颜色等，而不会影响布局时，页面的更新就叫做重绘。
* 因此，回流一定会发生重绘，重绘不一定会发生回流。  

**针对回流和重绘的优化**  
CSS：  
* 避免使用table布局  
* 尽量在DOM树的最末端改变class  
* 避免设置多层内联样式  
* 将动画效果应用到position属性为absolute或fixed的元素上  

Javascript：  
* 避免频繁操作样式，可以将样式写在class中然后统一改写class  
* 避免频繁操作DOM，可以创建一个documentFragment，在其中书写DOM操作，最后添加到文档中  
* 也可以先将元素设置display:none，操作结束后再显示，none元素上进行DOM操作不会引发回流和重绘  

扩展：  
为什么CSS放在head中，js放在body最后？  
因为js会阻塞DOM渲染，为了用户体验需要优先加载显示页面。  

## 断开连接  
现在的页面为了优化请求耗时，默认都会开启持久连接，所以TCP连接断开的时间一般是这个tab页关闭时。  
### 四次挥手  
<img src="@alias/tcp2.png" style="zoom:80%"/>  

TCP半关闭：连接端在结束数据发送后还能接收另一端的数据。  
客户端或服务器均可发起主动挥手过程。  

**过程：**  
（1）主机A数据发送完毕时，向主机B发送带有FIN标记的报文段，FIN=1，序列号seq=u  
（2）主机B收到后，向主机A发送一个确认序号ACK，ACK=1,ack=u+1,序列号seq=v（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）  
（3）主机B应用程序处理完请求后，向主机A发送FIN报文段，FIN=1，ACK=1，seq=w，ack=u+1。  
（4）主机A受到FIN报文段后，向主机B发送一个ACK表示连接彻底释放，ACK=1，seq=u+1，ack=w+1。  
注意：如果是客户端收到连接释放报文段，则发送完确认报文段后主动关闭并进入TIME_WAIT状态，等待设置的计时器时间2MSL后，再进入CLOSED状态。  
整个过程中，主机A首先停止发送，然后主机B发送完成之后也停止发送，两者断开。  
**1. 为什么需要四次挥手？**  
* TCP是全双工通信，断开时需要确定客户端和服务器都不再发送数据  
* 另外，服务端收到连接断开请求后，可能其中程序还没有处理完请求响应，所以先发送一个ACK告诉客户端“你发的FIN报文段我收到了”。等到程序处理完之后，服务端再发送一个FIN报文段，我发送完成了，可以断开了，所以需要四次挥手。  

**2. 2MSL等待状态**  
* TIME_WAIT状态也称为2MSL等待状态。MSL表示TCP报文段最大生存时间。  
* 当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留时间为2倍的MSL。若服务器没收到该ACK，则会超时重传FIN-ACK，然后客户端再次发送ACK，保证服务器能够收到。  
* 还可以防止已失效的连接请求报文段出现再本连接中，因为经过2MSL，本连接的所有报文段会从网络上消失，不影响下一个新的连接。  