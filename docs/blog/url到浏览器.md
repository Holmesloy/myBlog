---  
title: url 输入浏览器运行过程  
date: 2020-12-06  
categories:  
 - frontEnd  
tags:  
 - http  
 - 浏览器  
---  
## 主体流程  
* DNS 解析（域名转化为 ip 地址）  
* TCP 连接（三次握手）  
* 浏览器发送 http 请求  
* 服务器处理请求  
* 浏览器解析并渲染页面  
* 断开连接（四次挥手）  

## DNS 解析  
在 DNS 解析前，浏览器会首先进行 url 合法性和安全性检查，然后去查找缓存（这里可以扩展缓存知识）。  
DNS 解析：域名转化为 ip 地址  
**DNS 缓存查找顺序：**  
![dns1](@alias/dns.png)  
**DNS 域名解析过程**  
![dns](@alias/dns1.png)  
**网址解析过程**  
* 高级域名到低级域名：. -> .com -> google.com. -> www.google.com.  

**DNS 负载均衡技术**  
在 DNS 服务器中，为一个主机名配置多个 ip 地址，按需返回不同的解析结果，使不同的客户端访问不同的服务器。  
扩展：DNS 解析过程中，还可能会发生 DNS 劫持问题，然后还有前端的 dns-prefetch 优化。  

## 建立 TCP 连接  
### 三次握手  
<img src="@alias/tcp1.png" style="zoom:36%"/>  
 
SYN（Synchronize Sequence Numbers）：同步序列编号  
ACK（Acknowledge character）：确认字符  

**过程：**  
1. 客户端给服务器发送一个 SYN 报文，并确定初始化序列号 seq=x，此时 SYN=1，报文段不能携带数据  
2. 服务器返回确认 SYN 报文，SYN=1，并确定初始化序列号 seq=y，并返回确认帧 ACK=1，ACK 确认号的值 ack=x+1  
3. 客户端收到后返回确认帧 ACK=1，确认号 ack=y+1，序列号 seq=x+1，此时 ACK 报文段可以携带数据，数据会消耗序号  

**1. 为什么需要三次握手，两次不行吗？**  
* 三次握手的目的是确认双方的接收与发送能力都正常。  
* 第三次为了防止已经失效的连接请求到达服务端，让服务器错误打开连接。  
* 如果只是两次握手就建立连接的话，若客户端之前发送的一些失效请求又到达了服务端，那么服务器就会发送确认，直接建立连接，然后等待客户端发送数据，实际上这时候客户端并没有要发送数据，浪费了资源。  

**2. SYN-ACK 重传次数**  
服务器发送回SYN-ACK包，若未收到客户端确认包，则服务器进行重传，每次重传间隔时间一般是指数增长。  
若超过最大重传次数，则系统将该连接信息从半连接队列中删除。  

**3. ISN（Initial Sequence Number）是固定的吗？**  
客户端和服务端需要交换 ISN，因为接收数据时要按照序列号组装数据，保证可靠传输。如果 ISN 固定，则攻击者容易猜出后序的确认号，因此 ISN 是动态生成的。  

**4. 三次握手过程中可以携带数据吗?**  
* 第三次握手可以携带数据，第一次、第二次不可以。  
* 如果第一次可以携带数据，那么服务器会比较容易受到恶意攻击，攻击者会发送很多数据给服务器，造成服务器响应缓慢。  
* 第三次握手客户端已经知道服务器的接收和发送能力，因此可以携带数据。  

**5. SYN 洪泛攻击**  
一种典型的 Dos/DDos 攻击：  
* 服务器端资源是在第二次握手时分配，客户端资源是三次握手时分配，因此服务器容易受到 SYN 攻击  
* 客户端短时间内伪造大量不存在 IP 地址，向服务器不断发送 SYN 包，服务器发送回复但接收不到确认包，因此不断重发至超时  
* 伪造 SYN 包长时间占用队列，使正常 SYN 包被丢弃，使网络阻塞甚至瘫痪  

**防御 SYN 攻击的方法：**  
* 缩短超时（SYN Timeout）时间  
* 增加最大半连接数  
* 过滤网关防护  

**6. 第三次握手失败怎么办？**  
服务器不会重传 ack 报文，而是发送 RST 报文段，进入 CLOSED 状态，防止 SYN 洪泛攻击。  

**总结**  
* 三次握手建立连接的主要目的是同步序列号，保证可靠传输。  
* TCP 很多特性如流量控制、消息重发等依赖于序列号  
* 因此，三次握手中的报文被称为 SYN  

## 发送 HTTP 请求  
客户端向服务器发送 HTTP 请求（应用层），请求信息包括：  
请求头（Request Header）：请求方法、目标地址、遵循协议等  
请求主体（其他参数）  
注：可以扩充 http 字段知识  

## 服务器处理请求  
HTTP 响应报文由以下部分构成：  
状态行  
响应头（Response Header）  
响应正文  

## 浏览器解析并渲染页面  
整体过程：  
构建 DOM 树 -> 构建 CSSOM 树 -> 构建 render 树 -> 绘制 render 树  
详细过程如下：  
* 解析 HTML 形成 DOM 树  
* 解析 CSS 形成 CSSOM（CSS 规则）树  
* 合并 DOM 树和 CSSOM 树形成布局树（Layout Tree） 
* 渲染并绘制页面  

**页面绘制过程：**  
* 回流：当页面中的一部分（或全部）因为元素的规模尺寸、布局，隐藏等属性改变而需要重新构建（也可以称为重布局或者重排）。每个页面至少产生一次回流，即第一次加载时。  
* 重绘：当页面中的一些元素需要更新属性，而这些属性只影响元素的外观，诸如背景颜色、文字颜色等，而不会影响布局时，页面的更新就叫做重绘。
* 因此，回流一定会发生重绘，重绘不一定会发生回流。  

**针对回流和重绘的优化**  
CSS：  
* 避免使用 table 布局  
* 尽量在 DOM 树的最末端改变 class  
* 避免设置多层内联样式  
* 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上  

Javascript：  
* 避免频繁操作样式，可以将样式写在 class 中然后统一改写 class  
* 避免频繁操作 DOM，可以创建一个 documentFragment，在其中书写 DOM 操作，最后添加到文档中  
* 也可以先将元素设置 display:none，操作结束后再显示，none 元素上进行 DOM 操作不会引发回流和重绘  

扩展：  
为什么 CSS 放在head中，js 放在 body 最后？  
因为 js 会阻塞 DOM 渲染，为了用户体验需要优先加载显示页面。  

## 断开连接  
现在的页面为了优化请求耗时，默认都会开启持久连接，所以 TCP 连接断开的时间一般是这个 tab 页关闭时。  
### 四次挥手  
<img src="@alias/tcp2.png" style="zoom:80%"/>  

TCP 半关闭：连接端在结束数据发送后还能接收另一端的数据。  
客户端或服务器均可发起主动挥手过程。  

**过程：**  
（1）主机 A 数据发送完毕时，向主机 B 发送带有 FIN 标记的报文段，FIN=1，序列号 seq=u  
（2）主机 B 收到后，向主机A发送一个确认序号 ACK，ACK=1,ack=u+1,序列号 seq=v（先发送 ACK 的目的是为了防止在这段时间内，对方重传 FIN 报文段）  
（3）主机 B 应用程序处理完请求后，向主机 A 发送FIN报文段，FIN=1，ACK=1，seq=w，ack=u+1。  
（4）主机 A 受到 FIN 报文段后，向主机 B 发送一个 ACK 表示连接彻底释放，ACK=1，seq=u+1，ack=w+1。  
注意：如果是客户端收到连接释放报文段，则发送完确认报文段后主动关闭并进入 TIME_WAIT 状态，等待设置的计时器时间 2MSL 后，再进入 CLOSED 状态。  
整个过程中，主机 A 首先停止发送，然后主机 B 发送完成之后也停止发送，两者断开。  
**1. 为什么需要四次挥手？**  
* TCP 是全双工通信，断开时需要确定客户端和服务器都不再发送数据  
* 另外，服务端收到连接断开请求后，可能其中程序还没有处理完请求响应，所以先发送一个 ACK 告诉客户端“你发的FIN报文段我收到了”。等到程序处理完之后，服务端再发送一个 FIN 报文段，我发送完成了，可以断开了，所以需要四次挥手。  

**2. 2MSL 等待状态**  
* TIME_WAIT 状态也称为 2MSL 等待状态。MSL 表示 TCP 报文段最大生存时间。  
* 当 TCP 执行一个主动关闭，并发回最后一个 ACK，该连接必须在 TIME_WAIT 状态停留时间为 2 倍的 MSL。若服务器没收到该 ACK，则会超时重传 FIN-ACK，然后客户端再次发送 ACK，保证服务器能够收到。  
* 还可以防止已失效的连接请求报文段出现再本连接中，因为经过 2MSL，本连接的所有报文段会从网络上消失，不影响下一个新的连接。  