# HTTP  
![http](@alias/http.png)  

## HTTP基本概念  
HTTP（HyperText Transfer Protocal），超文本传输协议。用于浏览器与服务器之间的数据传输。  

### HTTP状态码  
![state](@alias/http1.png)  
常用状态码：  
* 200 OK：响应成功，数据正确返回  
* 204 No Content：响应成功，但是响应头没有body数据  
* 206 Partial Content：HTTP分块下载，响应返回的body数据并不是全部  
*********  
* 301 Move Permanently：永久重定向，说明请求资源不存在了，需要使用新的URL访问，配合location，浏览器自动跳转    
* 302 Moved Temporaryly：临时重定向，说明请求的资源还在，但是暂时需要另一个URL来访问，配合location，浏览器自动跳转  
* 304 Not Modified：资源未修改，重定向已存在的缓存文件  
**********  
* 400 Bad Request：表示客户端请求的报文有错误，笼统的错误码  
* 401 Unauthorized：未授权，表示请求未携带需要的认证信息  
* 403 Forbidden：表示请求携带了认证信息，但是服务器认为该信息用户无访问权限，禁止访问  
* 404 Not Found：请求的资源不存在或者未找到  
**********  
* 500 Internal Server Error：服务器错误，也是笼统的错误码  
* 501 Not Implemented：表示客户端请求的功能还不支持  
* 502 Bad Gateway：服务器作为网关或代理时返回的错误码，表示服务器工作正常，而后端服务器发生了错误  
* 503 Service Unavailable：服务器繁忙，无法响应  
* 504 Gateway timeout：网关超时  

**常见Request Headers（客户端发送）**  
* Accept：浏览器可接收的数据格式  
* Accept-Encoding：浏览器可接收的压缩算法，如gzip（减小资源体积）  
* Accept-Languange：浏览器可接收的语言，如zh-CN  
* Connection：keep-alive —— 一次TCP连接重复使用，持久连接  
* cookie  
* Host：发送请求时的域名  
* User-Agent（UA）：浏览器信息  
* Content-Type：发送数据的格式，如application/json  
* If-Modified-Since：本地浏览器存储的文件修改时间  
* If-None-Match：本地浏览器存储的资源标识  

**常见Response Headers（服务器返回）**  
* Content-Type：返回的数据格式，如text/html  
* Content-Length：返回数据的大小（字节）  
* Content-Encoding：返回数据的压缩算法，如gzip  
* Set-Cookie：服务器改变的cookie  
* Cache-Control：缓存有效时间设置  
* Last-Modified：服务器存储的资源的最后修改时间（秒级）  
* Etag：服务器端资源的唯一标识（一个字符串）  

## 现今的HTTP方法（约定的规范）  
* get：获取数据  
* post：新建数据  
* patch/put：更新数据  
* delete：删除数据  

### Restful API  
* 一种API设计方法  
* 传统API设计：把每个url当作一个功能  
* Restful API设计：把每个url当作一个唯一的资源  

**设计成资源的方法**  
1. 尽量不用url参数  
   * 传统API设计：/api/list?pageIndex=2  
   * Restful API设计：/api/list/2  
2. 用method表示操作类型  
   * 传统API设计：post请求 —— /api/create-blog  
   * Restful API设计：post请求 —— /api/blog  
   * patch请求 —— /api/blog/100（只有看到方法才知道api功能）  

### Get 和 Post  
HTTP协议中，  
「安全」表示请求方法不会「破坏」服务器上的资源，  
「幂等」表示多次执行相同的操作，结果都是「相同」的。  
因此，GET方法就是安全且幂等的，POST方法是不安全且不幂等的。  

## HTTP缓存  
* 需要重复获取的资源进行缓存，下次访问的时候就不需要重新请求  
* 由于网络请求速度较慢，所以需要尽量减少网络请求，提高页面加载速度  
* 通常可以缓存的资源是一些静态资源，如js、css、img  

![HTTP缓存](@alias/huancun.png)  
### 强制缓存  
**Cache-Control**  
当服务器响应请求时，如果服务器觉得资源可以被缓存，就返回Cache-Control字段  
* Response Headers中  
* 控制强制缓存的逻辑  
* 例如Cache-Control：max-age=31536（单位是s）  
* 再次请求时若强制缓存可用，则不使用网络请求  
* 若强制缓存不可用，则再次发送请求访问服务器获取数据  
* 注：服务器资源改变  

**Expires**
* http1.0中字段，优先级弱于Cache-Control

<img alt="强制缓存" src="@alias/huancun1.png" style="zoom:50%">  

**Cache-Control的值**  
* max-age：最长缓存有效时间，如max-age=3600
* 组合属性：public-客户端和代理服务器都可以缓存；private-只有浏览器缓存
* no-cache：不使用强制缓存  
* no-store：不使用任何缓存  

### 协商缓存  
* 服务端缓存策略  
* 服务端判断客户端资源，是否与服务端一样  
* 一致则返回304，使用缓存，否则返回200和最新的资源  

<img alt="协商缓存" src="@alias/huancun2.png" style="zoom:50%">  

**资源标识**  
* 在Response Headers中，有以下两种：  
* Last-Modified：资源的最后修改时间（精确到秒级）  
* Etag：资源的唯一标识（一个唯一字符串，优先使用）  
* 如果资源被重复生成，而内容不变，则适合使用Etag  

<img alt="Last-Modified" src="@alias/huancun3.png" style="zoom:50%">  
<img alt="Etag" src="@alias/huancun4.png" style="zoom:50%">  

### 最佳实践
当使用vue-cli打包后会生成一个html，以及一堆css、img资源等，其中
* index.html采用协商缓存，保证资源更新后可以及时访问
* 其他资源采用强缓存+协商缓存

### 刷新操作  
| 类别 | 操作 | 对缓存的影响 |  
| :---    | :--- | :--- |  
|正常刷新| 地址栏输入url，跳转链接，前进后退等 | 强制缓存和协商缓存均有效 |  
|手动刷新 | F5，点击刷新按钮，右击菜单刷新 | 强制缓存失效，协商缓存有效 |  
|强制刷新 | ctrl + F5 | 强制缓存和协商缓存都失效 |  


## HTTP特性  
### 优点  
1. 简单  
   HTTP基本报文格式就是`header + body`，头部信息也是`key-value`形式，易于理解和使用  
2. 灵活和易于扩展  
   HTTP协议中的各类请求方法、URI、状态码、头字段等每个组成都没有被固定死，允许开发人员自定义和扩充  
3. 应用广泛和跨平台  
   从电脑浏览器到手机浏览器，从电脑客户端到手机客户端都可用。  

### 缺点  
1. 无状态双刃剑  
   好处是不需要额外资源来记录状态信息，节省CPU和内存资源。坏处是服务器没有记忆能力，那么很多操作比如购物下单等将十分麻烦！  
2. 明文传输  
3. 不安全  
   通信使用明文，而且不验证通信方身份，有可能访问如假的淘宝等。另外，无法证明报文的完整性，则可能被篡改，如各种垃圾广告。  

## HTTP的性能  
HTTP协议基于TCP/IP，使用了**请求-应答**的通信模式，这是性能的关键点。  
**1. 长连接**  
HTTP/1.1提出长连接的通信方式，即持久连接，只要任意一端没有明确提出断开连接，则保持TCP连接状态。  
这种方式减少了连接的重复建立和断开的额外开销，减轻了服务器端的负载。  
**2. 管道网络运输**  
基于HTTP/1.1的长连接，可用使用管道运输。  
在同一个TCP连接里面，客户端可以发起多个请求，即不用等待响应，即可继续发送下一个请求，减少整体的响应时间。  
服务器的响应还是按照顺序来的，一个一个回应。如果前面的回应等待时间过长，后面很多在排队，则造成队头阻塞。  

## HTTP与HTTPS  
**区别**  
* HTTPS在TCP和网络层之间加入了SSL/TLS安全协议，进行加密传输。  
* HTTPS在TCP进行三次握手之后，还需要加入SSL/TLS的握手过程，进入加密报文传输。  
* HTTP的端口号是80，HTTPS的端口号是443。  
* HTTPS需要向CA（证书权威机构）申请数字证书，保证服务器的身份可信  

**解决方案**  
* 信息加密：交互信息无法被窃取  
* 校验机制：无法篡改通信内容  
* 身份证书：证明网站的真实性  

**实现方式**  
1. 混合加密  
   对称加密 + 非对称加密：在通信建立前采用非对称加密交换会话密钥，后续通信过程全部使用对称加密传输数据。  
   对称加密使用一个密钥，运算速度快，但是必须保密，无法做到安全的密钥交换。非对称加密使用公钥和私钥，公钥公开，私钥保密，解决了密钥交换问题但速度较慢。  
2. 摘要算法  
   摘要算法用来实现完整性，为数据生成独一无二的**指纹**，用于校验数据的完整性，解决了篡改的风险。  

### HTTPS过程  
![HTTPS](@alias/https.png)  
1. 客户端向服务器发起HTTPS的请求，连接到服务器的443端口；  

2. 服务器将非对称加密的公钥传递给客户端，以证书的形式回传到客户端  

3. 客户端接受到该公钥进行验证，就是验证2中证书，如果没有问题，则上述公钥是合格的。（第一次HTTP请求）客户端这个时候随机生成一个密钥（用作对称加密），称为client key。然后使用前面服务器的公钥对client key进行非对称加密，客户端的密钥就变成密文了；  

4. 客户端发起HTTPS中第二次HTTP请求，将加密之后的client key传递给服务器；  

5. 服务器使用私钥进行解密，得到client key,使用client key对数据进行对称加密  

6. 将对称加密的数据传递给客户端，客户端使用客户端密钥解密，得到服务器发送的数据，完成第二次HTTP请求。  

## HTTP/1.0、HTTP/1.1、HTTP/2.0、HTTP/3  

### HTTP/1.1相对HTTP1.0  
* 使用TCP长连接方式改善性能  
* 支持管道网络传输，只要请求发出去不必等待响应就可发送第二个请求  

**HTTP1.1瓶颈**  
* 头部（Header）未经压缩就发送，首部信息越多延迟越大，且浪费资源  
* 服务器按照请求顺序响应，若服务器响应慢，客户端则get不到数据，造成队头阻塞  
* 没有请求优先级控制  
* 请求只能从客户端开始，服务器被动响应  
### HTTP2.0改进  
HTTP2.0基于HTTPS，因此安全性有保障  
* 首部压缩：若同时发出多个请求，如果头部一样或相似，则HTTP2会消除重复的部分。（HPACK算法：客户端和服务器同时维护一张头部信息表，字段存入这个表，生成一个索引号，以后直接发送索引号）。  
* 二进制格式：之前报文都是纯文本形式，2.0全部采用二进制格式，被称为帧，提高了数据传输的效率。  
* 数据流：数据包不再按顺序发送，每个请求或回应对应的所有数据包，称为一个数据流，数据流有编号，客户端还可以指定数据流的优先级。  
* 多路复用：在一个连接中并发多个请求或回应，不用按照顺序一一对应，降低延迟，提高连接利用率  
* 服务器推送：服务器可以主动向客户端推送数据  

**HTTP2.0缺陷**  
多个HTTP请求复用一个TCP连接，一旦丢包，就会阻塞所有的HTTP请求  
### HTTP3.0改进  
HTTP3.0把HTTP下层的TCP协议改成了UDP协议  
UDP发生不管顺序，也不管丢包，所以不会出现队头阻塞和一个丢包全部重传。  
由于UDP是不可靠传输，所以实际上使用的是基于UDP的**QUIC协议**实现类似TCP的可靠传输。  
QUIC中，若某个流发生丢包，只会阻塞这个流。建立连接时，减少了交互次数，将三次握手和TLS三次握手合并为3次交互。  
总结：QUIC是一个在UDP之上的伪TCP + TLS + HTTP/2的多路复用协议。  
目前HTTP3并未普及，因为很多网络设备不知道什么是QUIC，只会当作UDP，所以目前兼容性存在问题。  

## 计算机网络知识  
### 五层网络模型  
![net](@alias/netmodel.png)
* 物理层：物理设备
* 数据链路层：建立数据链路连接，传输基础数据流
* 网络层：数据在节点间创建逻辑链路，网络寻址
* 传输层：提供可靠的端到端服务
* 应用层：应用软件服务，如HTTP协议
### TCP和UDP的区别  
* TCP面向连接，发送数据前要先建立连接。UDP无连接
* TCP提供可靠服务，无差错、不丢失。UDP不保证可靠传输
* TCP面向字节流，数据为一连串字节流。UDP是面向报文的
* TCP首部开销20字节，UDP首部开销8字节，UDP更加简单高效
* TCP点对点，UDP可以多对多

### TCP协议
**ARQ协议**
超时重传协议，过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ。

**滑动窗口**
在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口
发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。
滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。

**拥塞处理**
1. 慢开始：传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。
2. 拥塞避免：每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。
3. 快启动：一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。

### 应用层协议，使用TCP还是UDP  
| 应用层协议 | 传输层协议 |
| :-- | :-- |
| HTTP协议 | TCP |
| FTP文件传输协议 | TCP |
| SMTP邮件发送协议| TCP |
| POP3邮件接收协议| TCP |
| DNS域名系统| UDP |
| DHCP协议，动态获取IP地址| UDP |

### CDN
* Content Delivery NetWork，内容分发网络
* 简单理解：将资源分配到各个地区中，根据用户IP地址去访问最近资源，加快访问速度
* 本质是将媒体资源内容缓存到距离最近的IDC，从而让用户共享资源，缩短站点间响应时间
* 由边缘结点和中心结点组成
* 相关技术：内容发布、内容存储、内容路由、内容管理
