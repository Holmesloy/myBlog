(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{558:function(t,v,e){t.exports=e.p+"assets/img/toRefs.40212202.jpg"},622:function(t,v,e){"use strict";e.r(v);var _=e(5),a=Object(_.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"vue3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3"}},[t._v("#")]),t._v(" Vue3")]),t._v(" "),_("h2",{attrs:{id:"vue3-对比-vue2-优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3-对比-vue2-优势"}},[t._v("#")]),t._v(" Vue3 对比 Vue2 优势")]),t._v(" "),_("ul",[_("li",[t._v("性能更好，体积更小")]),t._v(" "),_("li",[t._v("更好的 ts 支持")]),t._v(" "),_("li",[t._v("更好的代码组织与逻辑抽离")])]),t._v(" "),_("h2",{attrs:{id:"vue3-生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3-生命周期"}},[t._v("#")]),t._v(" Vue3 生命周期")]),t._v(" "),_("h3",{attrs:{id:"composition-api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#composition-api"}},[t._v("#")]),t._v(" Composition API")]),t._v(" "),_("p",[t._v("setup() 函数中使用 onBeforeMount(() => {}) 形式去书写全部生命周期，组织在一起")]),t._v(" "),_("h2",{attrs:{id:"composition-api-与-options-api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#composition-api-与-options-api"}},[t._v("#")]),t._v(" Composition API 与 Options API")]),t._v(" "),_("h2",{attrs:{id:"ref-toref-和-torefs"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ref-toref-和-torefs"}},[t._v("#")]),t._v(" ref toRef 和 toRefs")]),t._v(" "),_("h3",{attrs:{id:"ref"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[t._v("#")]),t._v(" ref")]),t._v(" "),_("ul",[_("li",[t._v("除了模板外，一律用 ref.value 形式取值")]),t._v(" "),_("li",[t._v("与 reactive 可联合使用")]),t._v(" "),_("li",[t._v("定义的值记得使用 return")])]),t._v(" "),_("h3",{attrs:{id:"toref"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#toref"}},[t._v("#")]),t._v(" toRef")]),t._v(" "),_("ul",[_("li",[t._v("用于一个响应式对象（reactive 封装）的其中一个属性实现响应式")]),t._v(" "),_("li",[t._v("创建一个 ref，具有响应式")]),t._v(" "),_("li",[t._v("两者保持引用关系")])]),t._v(" "),_("h3",{attrs:{id:"torefs"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#torefs"}},[t._v("#")]),t._v(" toRefs")]),t._v(" "),_("ul",[_("li",[t._v("将响应式对象（reactive 封装）转换为普通对象，有时候方便使用")]),t._v(" "),_("li",[t._v("对象的每个 prop 都是对应的 ref")]),t._v(" "),_("li",[t._v("两者保持引用关系")])]),t._v(" "),_("h3",{attrs:{id:"最佳使用方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最佳使用方式"}},[t._v("#")]),t._v(" 最佳使用方式")]),t._v(" "),_("ul",[_("li",[t._v("用 reactive 做对象的响应式，用 ref 做值类型响应式")]),t._v(" "),_("li",[t._v("setup 中返回 toRefs(state)，或者 toRef(state, 'xx')")]),t._v(" "),_("li",[t._v("ref 变量命名使用 xxRef")]),t._v(" "),_("li",[t._v("合成函数返回响应式对象时，使用 toRefs")])]),t._v(" "),_("p",[_("img",{attrs:{src:e(558),alt:"toRefs"}})]),t._v(" "),_("h3",{attrs:{id:"为什么需要-ref"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-ref"}},[t._v("#")]),t._v(" 为什么需要 ref")]),t._v(" "),_("ul",[_("li",[t._v("返回值类型，会丢失响应式")]),t._v(" "),_("li",[t._v("如在 setup、computed、合成函数，都有可能返回值类型")]),t._v(" "),_("li",[t._v("Vue 如不定义 ref，用户将自己自造 ref，反而混乱")])]),t._v(" "),_("h3",{attrs:{id:"ref-value"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ref-value"}},[t._v("#")]),t._v(" ref .value")]),t._v(" "),_("ul",[_("li",[t._v("ref 是一个对象（保证响应式），用 value 存储值")]),t._v(" "),_("li",[t._v("通过 value 属性的 get 和 set 实现响应式")]),t._v(" "),_("li",[t._v("用于模板、reactive 时，不需要 .value，其他情况都需要")])]),t._v(" "),_("h3",{attrs:{id:"为什么需要-toref、torefs"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-toref、torefs"}},[t._v("#")]),t._v(" 为什么需要 toRef、toRefs")]),t._v(" "),_("ul",[_("li",[t._v("不丢失响应式的情况下，把数据分解/扩散")]),t._v(" "),_("li",[t._v("前提：针对的是响应式对象（reactive 封装）")]),t._v(" "),_("li",[t._v("注意：不创造响应式，而是延续响应式")])]),t._v(" "),_("h2",{attrs:{id:"vue3-新功能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3-新功能"}},[t._v("#")]),t._v(" Vue3 新功能")]),t._v(" "),_("ul",[_("li",[t._v("createApp")]),t._v(" "),_("li",[t._v("emits 属性（setup 中第二个参数）")]),t._v(" "),_("li",[t._v("生命周期")]),t._v(" "),_("li",[t._v("Fragment：根节点不用一个单一父节点包裹了")]),t._v(" "),_("li",[t._v("异步组件：引入 Vue 一个方法")]),t._v(" "),_("li",[t._v("移除 .sync")]),t._v(" "),_("li",[t._v("移除 filter")]),t._v(" "),_("li",[t._v("Teleport：选择插入 DOM 位置")]),t._v(" "),_("li",[t._v("Suspense：具名插槽封装")]),t._v(" "),_("li",[t._v("Compostion API")])]),t._v(" "),_("h2",{attrs:{id:"compositon-api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#compositon-api"}},[t._v("#")]),t._v(" Compositon API")]),t._v(" "),_("h3",{attrs:{id:"逻辑复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#逻辑复用"}},[t._v("#")]),t._v(" 逻辑复用")]),t._v(" "),_("ul",[_("li",[t._v("抽离逻辑代码到一个函数")]),t._v(" "),_("li",[t._v("函数命名约定为 useXxx 格式（同 React Hooks）")]),t._v(" "),_("li",[t._v("在 setup 中引入 useXxx 函数")])]),t._v(" "),_("h3",{attrs:{id:"与-hooks-对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与-hooks-对比"}},[t._v("#")]),t._v(" 与 Hooks 对比")]),t._v(" "),_("ul",[_("li",[t._v("setup 只会被调用一次，而 Hooks 函数会被多次调用")]),t._v(" "),_("li",[t._v("前者无需 useMemo useCallback，因为 setup 只调用一次")]),t._v(" "),_("li",[t._v("前者无需顾虑调用顺序，后者需要保证 Hooks 的顺序一致")])]),t._v(" "),_("h2",{attrs:{id:"vue3-原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3-原理"}},[t._v("#")]),t._v(" Vue3 原理")]),t._v(" "),_("ul",[_("li",[t._v("Vue2：Object.defineProerty")]),t._v(" "),_("li",[t._v("Proxy 语法与实现响应式")])]),t._v(" "),_("h3",{attrs:{id:"proxy-实现响应式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#proxy-实现响应式"}},[t._v("#")]),t._v(" Proxy 实现响应式")]),t._v(" "),_("p",[_("strong",[t._v("Reflect 作用")])]),t._v(" "),_("ul",[_("li",[t._v("和 Proxy 能力一一对应")]),t._v(" "),_("li",[t._v("规范化、标准化、函数式")]),t._v(" "),_("li",[t._v("逐步替代 Object 上的工具函数")])]),t._v(" "),_("p",[_("strong",[t._v("响应式实现")])]),t._v(" "),_("ul",[_("li",[t._v("深度监听，性能更好")]),t._v(" "),_("li",[t._v("可监听新增/删除属性")]),t._v(" "),_("li",[t._v("原生监听数组变化")]),t._v(" "),_("li",[t._v("无法兼容所有浏览器，无法 polyfill")])]),t._v(" "),_("h3",{attrs:{id:"watch-和-watcheffect"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#watch-和-watcheffect"}},[t._v("#")]),t._v(" watch 和 watchEffect")]),t._v(" "),_("ul",[_("li",[t._v("两者都可监听 data 属性变化")]),t._v(" "),_("li",[t._v("watch 需要明确监听哪个属性")]),t._v(" "),_("li",[t._v("watchEffect 会跟据其中的属性，自动监听其变化")])]),t._v(" "),_("h3",{attrs:{id:"setup-中获取组件实例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#setup-中获取组件实例"}},[t._v("#")]),t._v(" setup 中获取组件实例")]),t._v(" "),_("ul",[_("li",[t._v("在 setup 和其他 Composition API 中没有 this")]),t._v(" "),_("li",[t._v("可通过 getCurrentInstance 获取当前实例")]),t._v(" "),_("li",[t._v("若使用 Options API 可正常使用 this")])]),t._v(" "),_("h3",{attrs:{id:"vue3-为何比-vue2-快"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3-为何比-vue2-快"}},[t._v("#")]),t._v(" Vue3 为何比 Vue2 快")]),t._v(" "),_("ul",[_("li",[t._v("Proxy 响应式")]),t._v(" "),_("li",[t._v("PatchFlag")]),t._v(" "),_("li",[t._v("hoistStatic")]),t._v(" "),_("li",[t._v("cachehandler：缓存事件")]),t._v(" "),_("li",[t._v("SSR 优化：与编译优化相似")]),t._v(" "),_("li",[t._v("tree-shaking：减少引用，按需引入")])]),t._v(" "),_("p",[_("strong",[t._v("PatchFlag")])]),t._v(" "),_("ul",[_("li",[t._v("编译模板时，动态节点做标记")]),t._v(" "),_("li",[t._v("标记，分为不同的类型，如 TEXT PROPS")]),t._v(" "),_("li",[t._v("diff 算法时，可以区分静态节点，以及不同类型的动态节点")])]),t._v(" "),_("p",[_("strong",[t._v("hoistStatic")])]),t._v(" "),_("ul",[_("li",[t._v("将静态节点的定义，提升到父作用域，缓存起来")]),t._v(" "),_("li",[t._v("多个相邻的静态节点，会被合并起来")]),t._v(" "),_("li",[t._v("典型的那空间换时间的优化策略")])]),t._v(" "),_("p",[_("strong",[t._v("Vite 为何启动快")])]),t._v(" "),_("ul",[_("li",[t._v("开发环境使用 ES6 Module，无需打包")]),t._v(" "),_("li",[t._v("生产环境使用 rollup，没有快很多")])])])}),[],!1,null,null,null);v.default=a.exports}}]);