(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{529:function(_,v,t){_.exports=t.p+"assets/img/dns.1c33fac0.png"},530:function(_,v,t){_.exports=t.p+"assets/img/dns1.0e8d3473.png"},531:function(_,v,t){_.exports=t.p+"assets/img/tcp1.d6e8cbde.png"},532:function(_,v,t){_.exports=t.p+"assets/img/tcp2.6cb4769c.png"},595:function(_,v,t){"use strict";t.r(v);var r=t(5),s=Object(r.a)({},(function(){var _=this,v=_.$createElement,r=_._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h2",{attrs:{id:"主体流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主体流程"}},[_._v("#")]),_._v(" 主体流程")]),_._v(" "),r("ul",[r("li",[_._v("DNS 解析（域名转化为 ip 地址）")]),_._v(" "),r("li",[_._v("TCP 连接（三次握手）")]),_._v(" "),r("li",[_._v("浏览器发送 http 请求")]),_._v(" "),r("li",[_._v("服务器处理请求")]),_._v(" "),r("li",[_._v("浏览器解析并渲染页面")]),_._v(" "),r("li",[_._v("断开连接（四次挥手）")])]),_._v(" "),r("h2",{attrs:{id:"dns-解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dns-解析"}},[_._v("#")]),_._v(" DNS 解析")]),_._v(" "),r("p",[_._v("在 DNS 解析前，浏览器会首先进行 url 合法性和安全性检查，然后去查找缓存（这里可以扩展缓存知识）。"),r("br"),_._v("\nDNS 解析：域名转化为 ip 地址"),r("br"),_._v(" "),r("strong",[_._v("DNS 缓存查找顺序：")]),r("br"),_._v(" "),r("img",{attrs:{src:t(529),alt:"dns1"}}),r("br"),_._v(" "),r("strong",[_._v("DNS 域名解析过程")]),r("br"),_._v(" "),r("img",{attrs:{src:t(530),alt:"dns"}}),r("br"),_._v(" "),r("strong",[_._v("网址解析过程")])]),_._v(" "),r("ul",[r("li",[_._v("高级域名到低级域名：. -> .com -> google.com. -> www.google.com.")])]),_._v(" "),r("p",[r("strong",[_._v("DNS 负载均衡技术")]),r("br"),_._v("\n在 DNS 服务器中，为一个主机名配置多个 ip 地址，按需返回不同的解析结果，使不同的客户端访问不同的服务器。"),r("br"),_._v("\n扩展：DNS 解析过程中，还可能会发生 DNS 劫持问题，然后还有前端的 dns-prefetch 优化。")]),_._v(" "),r("h2",{attrs:{id:"建立-tcp-连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#建立-tcp-连接"}},[_._v("#")]),_._v(" 建立 TCP 连接")]),_._v(" "),r("h3",{attrs:{id:"三次握手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),r("img",{staticStyle:{zoom:"36%"},attrs:{src:t(531)}}),_._v(" "),r("p",[_._v("SYN（Synchronize Sequence Numbers）：同步序列编号"),r("br"),_._v("\nACK（Acknowledge character）：确认字符")]),_._v(" "),r("p",[r("strong",[_._v("过程：")])]),_._v(" "),r("ol",[r("li",[_._v("客户端给服务器发送一个 SYN 报文，并确定初始化序列号 seq=x，此时 SYN=1，报文段不能携带数据")]),_._v(" "),r("li",[_._v("服务器返回确认 SYN 报文，SYN=1，并确定初始化序列号 seq=y，并返回确认帧 ACK=1，ACK 确认号的值 ack=x+1")]),_._v(" "),r("li",[_._v("客户端收到后返回确认帧 ACK=1，确认号 ack=y+1，序列号 seq=x+1，此时 ACK 报文段可以携带数据，数据会消耗序号")])]),_._v(" "),r("p",[r("strong",[_._v("1. 为什么需要三次握手，两次不行吗？")])]),_._v(" "),r("ul",[r("li",[_._v("三次握手的目的是确认双方的接收与发送能力都正常。")]),_._v(" "),r("li",[_._v("第三次为了防止已经失效的连接请求到达服务端，让服务器错误打开连接。")]),_._v(" "),r("li",[_._v("如果只是两次握手就建立连接的话，若客户端之前发送的一些失效请求又到达了服务端，那么服务器就会发送确认，直接建立连接，然后等待客户端发送数据，实际上这时候客户端并没有要发送数据，浪费了资源。")])]),_._v(" "),r("p",[r("strong",[_._v("2. SYN-ACK 重传次数")]),r("br"),_._v("\n服务器发送回SYN-ACK包，若未收到客户端确认包，则服务器进行重传，每次重传间隔时间一般是指数增长。"),r("br"),_._v("\n若超过最大重传次数，则系统将该连接信息从半连接队列中删除。")]),_._v(" "),r("p",[r("strong",[_._v("3. ISN（Initial Sequence Number）是固定的吗？")]),r("br"),_._v("\n客户端和服务端需要交换 ISN，因为接收数据时要按照序列号组装数据，保证可靠传输。如果 ISN 固定，则攻击者容易猜出后序的确认号，因此 ISN 是动态生成的。")]),_._v(" "),r("p",[r("strong",[_._v("4. 三次握手过程中可以携带数据吗?")])]),_._v(" "),r("ul",[r("li",[_._v("第三次握手可以携带数据，第一次、第二次不可以。")]),_._v(" "),r("li",[_._v("如果第一次可以携带数据，那么服务器会比较容易受到恶意攻击，攻击者会发送很多数据给服务器，造成服务器响应缓慢。")]),_._v(" "),r("li",[_._v("第三次握手客户端已经知道服务器的接收和发送能力，因此可以携带数据。")])]),_._v(" "),r("p",[r("strong",[_._v("5. SYN 洪泛攻击")]),r("br"),_._v("\n一种典型的 Dos/DDos 攻击：")]),_._v(" "),r("ul",[r("li",[_._v("服务器端资源是在第二次握手时分配，客户端资源是三次握手时分配，因此服务器容易受到 SYN 攻击")]),_._v(" "),r("li",[_._v("客户端短时间内伪造大量不存在 IP 地址，向服务器不断发送 SYN 包，服务器发送回复但接收不到确认包，因此不断重发至超时")]),_._v(" "),r("li",[_._v("伪造 SYN 包长时间占用队列，使正常 SYN 包被丢弃，使网络阻塞甚至瘫痪")])]),_._v(" "),r("p",[r("strong",[_._v("防御 SYN 攻击的方法：")])]),_._v(" "),r("ul",[r("li",[_._v("缩短超时（SYN Timeout）时间")]),_._v(" "),r("li",[_._v("增加最大半连接数")]),_._v(" "),r("li",[_._v("过滤网关防护")])]),_._v(" "),r("p",[r("strong",[_._v("6. 第三次握手失败怎么办？")]),r("br"),_._v("\n服务器不会重传 ack 报文，而是发送 RST 报文段，进入 CLOSED 状态，防止 SYN 洪泛攻击。")]),_._v(" "),r("p",[r("strong",[_._v("总结")])]),_._v(" "),r("ul",[r("li",[_._v("三次握手建立连接的主要目的是同步序列号，保证可靠传输。")]),_._v(" "),r("li",[_._v("TCP 很多特性如流量控制、消息重发等依赖于序列号")]),_._v(" "),r("li",[_._v("因此，三次握手中的报文被称为 SYN")])]),_._v(" "),r("h2",{attrs:{id:"发送-http-请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发送-http-请求"}},[_._v("#")]),_._v(" 发送 HTTP 请求")]),_._v(" "),r("p",[_._v("客户端向服务器发送 HTTP 请求（应用层），请求信息包括："),r("br"),_._v("\n请求头（Request Header）：请求方法、目标地址、遵循协议等"),r("br"),_._v("\n请求主体（其他参数）"),r("br"),_._v("\n注：可以扩充 http 字段知识")]),_._v(" "),r("h2",{attrs:{id:"服务器处理请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务器处理请求"}},[_._v("#")]),_._v(" 服务器处理请求")]),_._v(" "),r("p",[_._v("HTTP 响应报文由以下部分构成："),r("br"),_._v("\n状态行"),r("br"),_._v("\n响应头（Response Header）"),r("br"),_._v("\n响应正文")]),_._v(" "),r("h2",{attrs:{id:"浏览器解析并渲染页面"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器解析并渲染页面"}},[_._v("#")]),_._v(" 浏览器解析并渲染页面")]),_._v(" "),r("p",[_._v("整体过程："),r("br"),_._v("\n构建 DOM 树 -> 构建 CSSOM 树 -> 构建 render 树 -> 绘制 render 树"),r("br"),_._v("\n详细过程如下：")]),_._v(" "),r("ul",[r("li",[_._v("解析 HTML 形成 DOM 树")]),_._v(" "),r("li",[_._v("解析 CSS 形成 CSSOM（CSS 规则）树")]),_._v(" "),r("li",[_._v("合并 DOM 树和 CSSOM 树形成布局树（Layout Tree）")]),_._v(" "),r("li",[_._v("渲染并绘制页面")])]),_._v(" "),r("p",[r("strong",[_._v("页面绘制过程：")])]),_._v(" "),r("ul",[r("li",[_._v("回流：当页面中的一部分（或全部）因为元素的规模尺寸、布局，隐藏等属性改变而需要重新构建（也可以称为重布局或者重排）。每个页面至少产生一次回流，即第一次加载时。")]),_._v(" "),r("li",[_._v("重绘：当页面中的一些元素需要更新属性，而这些属性只影响元素的外观，诸如背景颜色、文字颜色等，而不会影响布局时，页面的更新就叫做重绘。")]),_._v(" "),r("li",[_._v("因此，回流一定会发生重绘，重绘不一定会发生回流。")])]),_._v(" "),r("p",[r("strong",[_._v("针对回流和重绘的优化")]),r("br"),_._v("\nCSS：")]),_._v(" "),r("ul",[r("li",[_._v("避免使用 table 布局")]),_._v(" "),r("li",[_._v("尽量在 DOM 树的最末端改变 class")]),_._v(" "),r("li",[_._v("避免设置多层内联样式")]),_._v(" "),r("li",[_._v("将动画效果应用到 position 属性为 absolute 或 fixed 的元素上")])]),_._v(" "),r("p",[_._v("Javascript：")]),_._v(" "),r("ul",[r("li",[_._v("避免频繁操作样式，可以将样式写在 class 中然后统一改写 class")]),_._v(" "),r("li",[_._v("避免频繁操作 DOM，可以创建一个 documentFragment，在其中书写 DOM 操作，最后添加到文档中")]),_._v(" "),r("li",[_._v("也可以先将元素设置 display:none，操作结束后再显示，none 元素上进行 DOM 操作不会引发回流和重绘")])]),_._v(" "),r("p",[_._v("扩展："),r("br"),_._v("\n为什么 CSS 放在head中，js 放在 body 最后？"),r("br"),_._v("\n因为 js 会阻塞 DOM 渲染，为了用户体验需要优先加载显示页面。")]),_._v(" "),r("h2",{attrs:{id:"断开连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#断开连接"}},[_._v("#")]),_._v(" 断开连接")]),_._v(" "),r("p",[_._v("现在的页面为了优化请求耗时，默认都会开启持久连接，所以 TCP 连接断开的时间一般是这个 tab 页关闭时。")]),_._v(" "),r("h3",{attrs:{id:"四次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),r("img",{staticStyle:{zoom:"80%"},attrs:{src:t(532)}}),_._v(" "),r("p",[_._v("TCP 半关闭：连接端在结束数据发送后还能接收另一端的数据。"),r("br"),_._v("\n客户端或服务器均可发起主动挥手过程。")]),_._v(" "),r("p",[r("strong",[_._v("过程：")]),r("br"),_._v("\n（1）主机 A 数据发送完毕时，向主机 B 发送带有 FIN 标记的报文段，FIN=1，序列号 seq=u"),r("br"),_._v("\n（2）主机 B 收到后，向主机A发送一个确认序号 ACK，ACK=1,ack=u+1,序列号 seq=v（先发送 ACK 的目的是为了防止在这段时间内，对方重传 FIN 报文段）"),r("br"),_._v("\n（3）主机 B 应用程序处理完请求后，向主机 A 发送FIN报文段，FIN=1，ACK=1，seq=w，ack=u+1。"),r("br"),_._v("\n（4）主机 A 受到 FIN 报文段后，向主机 B 发送一个 ACK 表示连接彻底释放，ACK=1，seq=u+1，ack=w+1。"),r("br"),_._v("\n注意：如果是客户端收到连接释放报文段，则发送完确认报文段后主动关闭并进入 TIME_WAIT 状态，等待设置的计时器时间 2MSL 后，再进入 CLOSED 状态。"),r("br"),_._v("\n整个过程中，主机 A 首先停止发送，然后主机 B 发送完成之后也停止发送，两者断开。"),r("br"),_._v(" "),r("strong",[_._v("1. 为什么需要四次挥手？")])]),_._v(" "),r("ul",[r("li",[_._v("TCP 是全双工通信，断开时需要确定客户端和服务器都不再发送数据")]),_._v(" "),r("li",[_._v("另外，服务端收到连接断开请求后，可能其中程序还没有处理完请求响应，所以先发送一个 ACK 告诉客户端“你发的FIN报文段我收到了”。等到程序处理完之后，服务端再发送一个 FIN 报文段，我发送完成了，可以断开了，所以需要四次挥手。")])]),_._v(" "),r("p",[r("strong",[_._v("2. 2MSL 等待状态")])]),_._v(" "),r("ul",[r("li",[_._v("TIME_WAIT 状态也称为 2MSL 等待状态。MSL 表示 TCP 报文段最大生存时间。")]),_._v(" "),r("li",[_._v("当 TCP 执行一个主动关闭，并发回最后一个 ACK，该连接必须在 TIME_WAIT 状态停留时间为 2 倍的 MSL。若服务器没收到该 ACK，则会超时重传 FIN-ACK，然后客户端再次发送 ACK，保证服务器能够收到。")]),_._v(" "),r("li",[_._v("还可以防止已失效的连接请求报文段出现再本连接中，因为经过 2MSL，本连接的所有报文段会从网络上消失，不影响下一个新的连接。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);